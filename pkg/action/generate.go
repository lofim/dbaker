package action

import (
	"dbaker/pkg/adapter"
	"dbaker/pkg/config"
	"dbaker/pkg/model"
	"encoding/json"
	"fmt"
	"os"
)

type generate struct {
	config  config.Config
	adapter adapter.PostgreSQLAdapter
}

func NewGenerate(config config.Config, adapter adapter.PostgreSQLAdapter) *generate {
	return &generate{
		config,
		adapter,
	}
}

func (g *generate) Execute() error {
	err := g.adapter.Init()
	if err != nil {
		return err
	}
	defer g.adapter.Close()

	var tables []model.Table
	recipeFilePath := fmt.Sprintf("./%s.recipe.json", g.config.Database)
	readJson(recipeFilePath, &tables)

	// filter out generated columns (these are generated by DB)
	for _, table := range tables {
		var nonGenColumns []model.Column
		for _, column := range table.Columns {
			if !column.IsGenerated {
				nonGenColumns = append(nonGenColumns, column)
			}
		}

		for iter := range g.config.DataSize {
			if err := g.adapter.WriteRow(table.Name, table.Schema, nonGenColumns, g.config.IterFrom+iter); err != nil {
				return fmt.Errorf("failed to write row to table: %w", err)
			}
		}
	}

	fmt.Println("Databse was populated successfully")

	return nil
}

func readJson(filePath string, tables *[]model.Table) error {
	contents, err := os.ReadFile(filePath)
	if err != nil {
		return err
	}

	err = json.Unmarshal(contents, tables)
	if err != nil {
		return err
	}

	return nil
}
